---
import { Post, MarkdownPost } from "../entities/Post";
import { Author } from "../entities/Author";
import { Category } from "../entities/Category";
import PostPreview from "./PostPreview.astro";

interface PostListProps {
  filter: {
    author?: string;
    category?: string;
    tag?: string;
  },
  offset?: number;
  limit?: number;
}

const { filter, limit } = Astro.props as PostListProps;
const offset = Astro.props.offset ?? 0;

const allPosts = await Astro.fetchContent<MarkdownPost>(
  "../../content/posts/*.md"
);
const allAuthors = await Astro.fetchContent<Author>(
  "../../content/authors/*.md"
);
const allCategories = await Astro.fetchContent<Category>(
  "../../content/categories/*.md"
);

const authorsBySlug = allAuthors.reduce(
  (authorsBySlug, author) => authorsBySlug.set(author.slug, author),
  new Map<string, Author>()
);

const categoriesBySlug = allCategories.reduce(
  (categoriesBySlug, category) =>
    categoriesBySlug.set(category.slug, category),
  new Map<string, Category>()
);

const filteredPosts = filter ? allPosts.filter((post) => {
  return (
    (!filter.author || post.author === filter.author) &&
    (!filter.category || post.categories.indexOf(filter.category) > -1) &&
    (!filter.tag || post.tags.indexOf(filter.tag) > -1)
  );
}) : allPosts;

filteredPosts.sort((a, b) => Date.parse(b.date) - Date.parse(a.date));

const postList: Post[] = (limit ? filteredPosts.slice(offset, offset + limit) : filteredPosts).map((post) => ({
  ...post,
  author: authorsBySlug.get(post.author),
  categories: post.categories.map((category) =>
    categoriesBySlug.get(category)
  ),
}));
---
<>
  {postList.map((post) => <PostPreview post={post} />)}
</>